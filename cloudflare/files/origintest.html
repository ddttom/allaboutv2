
<!DOCTYPE html>
<html>
  <head>
    <title>Building Adobe EDS Components - Simple Tools, AI Collaboration</title>
    <link rel="canonical" href="https://allabout.network/blogs/ddt/ai/building-adobe-eds-components-simple-tools-ai-collaboration">
    <meta name="description" content="A zero-dependency framework for Adobe Edge Delivery Services development using vanilla JavaScript, detailed documentation, and AI integration.">
    <meta property="og:title" content="Building Adobe EDS Components - Simple Tools, AI Collaboration">
    <meta property="og:description" content="A zero-dependency framework for Adobe Edge Delivery Services development using vanilla JavaScript, detailed documentation, and AI integration.">
    <meta property="og:url" content="https://allabout.network/blogs/ddt/ai/building-adobe-eds-components-simple-tools-ai-collaboration">
    <meta property="og:image" content="https://allabout.network/blogs/ddt/ai/media_1984a9510094bdf423caae96c957dabefc2c04969.png?width=1200&#x26;format=pjpg&#x26;optimize=medium">
    <meta property="og:image:secure_url" content="https://allabout.network/blogs/ddt/ai/media_1984a9510094bdf423caae96c957dabefc2c04969.png?width=1200&#x26;format=pjpg&#x26;optimize=medium">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Building Adobe EDS Components - Simple Tools, AI Collaboration">
    <meta name="twitter:description" content="A zero-dependency framework for Adobe Edge Delivery Services development using vanilla JavaScript, detailed documentation, and AI integration.">
    <meta name="twitter:image" content="https://allabout.network/blogs/ddt/ai/media_1984a9510094bdf423caae96c957dabefc2c04969.png?width=1200&#x26;format=pjpg&#x26;optimize=medium">
    <meta name="author" content="Tom Cranstoun">
    <meta name="longdescription" content="How to build production-ready Adobe EDS components without complex build systems or external dependencies. This framework demonstrates that sophisticated web development comes from clean thinking and good documentation, not elaborate toolchains. The ipynb-viewer block turns Jupyter notebooks into interactive testing environments. Combined with developer documentation built for AI but useful for people, AI skills, custom development utilities, and hundreds of files across multiple languages, you get what&#x27;s needed for professional EDS development with browser-based testing and automatic AI skill activation. Cherry-pick the patterns you need and combine them with Adobe&#x27;s official boilerplate for your production projects.">
    <meta name="linkedin" content="https://www.linkedin.com/in/tom-cranstoun/">
    <meta name="publication-date" content="08/Dec/2024">
    <script type="application/ld+json" data-error="error in json-ld: Unexpected token &#x27;a&#x27;, &#x22;article&#x22; is not valid JSON"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="/scripts/aem.js" type="module"></script>
    <script src="/scripts/scripts.js" type="module"></script>
    <link rel="stylesheet" href="/styles/styles.css">
  </head>
  <body>
    <header></header>
    <main>
      <div>
        <h1 id="building-adobe-eds-components---simple-tools-ai-collaboration">Building Adobe EDS Components - Simple Tools, AI Collaboration<br></h1>
        <div class="bio">
          <div>
            <div>Picture Here</div>
            <div>Web development doesn't need complex tooling - this framework proves you can build production-ready Adobe Edge Delivery Services components with nothing but vanilla JavaScript and precise documentation, allowing AI assistants to work with you.</div>
          </div>
        </div>
        <div class="index"></div>
        <h2 id="why-zero-dependencies-matter">Why Zero Dependencies Matter</h2>
        <p>The web development world often assumes you need elaborate build systems, countless npm packages, and layers of abstraction to create anything worthwhile. This framework challenges that assumption. Built entirely with vanilla JavaScript and no external dependencies, it delivers enterprise-grade capabilities through simple, maintainable code.</p>
        <p>The core insight is simple. Clean thinking and good documentation achieve more than complex toolchains. When you strip away the unnecessary layers, you're left with code that's easier to understand, faster to develop, and simpler to maintain.</p>
        <p>
          <picture>
            <source type="image/webp" srcset="./media_1984a9510094bdf423caae96c957dabefc2c04969.png?width=2000&#x26;format=webply&#x26;optimize=medium" media="(min-width: 600px)">
            <source type="image/webp" srcset="./media_1984a9510094bdf423caae96c957dabefc2c04969.png?width=750&#x26;format=webply&#x26;optimize=medium">
            <source type="image/png" srcset="./media_1984a9510094bdf423caae96c957dabefc2c04969.png?width=2000&#x26;format=png&#x26;optimize=medium" media="(min-width: 600px)">
            <img loading="lazy" alt="" src="./media_1984a9510094bdf423caae96c957dabefc2c04969.png?width=750&#x26;format=png&#x26;optimize=medium" width="698" height="352">
          </picture>
        </p>
        <h2 id="what-this-framework-provides">What This Framework Provides</h2>
        <p>The webcomponents-with-eds repository contains what you need for Adobe EDS development. The framework includes standard EDS blocks for reference and ipynb-viewer, a Jupyter notebook viewer that changes how you develop and test components.</p>
        <p>Want to see my ipynb viewer in action: <a href="https://allabout.network/blocks/ipynb-viewer/test.html">https://allabout.network/blocks/ipynb-viewer/test.html</a></p>
        <p>The development server runs in pure Node.js. It serves your local files first, falls back to a proxy for missing resources, and includes live reload, which automatically refreshes your browser when files change. Start the server, edit your components, see results instantly.</p>
        <p>The core framework has zero runtime dependencies. Development dependencies are optional and needed only for testing, linting, and building components that use external libraries.</p>
        <h2 id="built-for-ai-useful-for-people">Built for AI, Useful for People</h2>
        <p>Documentation makes or breaks any framework. This repository includes 32 files of development guidance organised by audience and purpose. These aren't generic tutorials - they're specific implementation guides with cross-references, real examples, and proven patterns.</p>
        <p>The documentation was built with AI assistants in mind. Modern development increasingly involves AI collaboration, and AI needs structured, detailed, cross-referenced information to be helpful. But here's what matters - documentation clear enough for AI is also transparent enough for humans. Better, actually. The structure that helps AI navigate complexity also helps developers.</p>
        <p>The <code>docs/for-ai/</code> directory organises documentation by audience. New developers start with the EDS guide and raw blocks documentation. Experienced developers move to complex blocks and architecture standards. Architects and tech leads review design philosophy and system architecture. Each path provides the information needed for that role.</p>
        <p>Cross-references create a web of knowledge. When you need information about testing, the documentation points you to relevant sections in architecture guides, implementation examples, and quality standards. This structure helps humans navigate the knowledge base - and works equally well for AI assistants.</p>
        <p>The "for-ai" name acknowledges reality. We work alongside AI assistants now. Documentation optimised for AI assistance is simply well-structured technical documentation. No compromise, no separate versions. One knowledge base that serves both audiences.</p>
        <h2 id="the-ipynb-viewer-block">The ipynb-viewer Block</h2>
        <p>The ipynb-viewer block enables Jupyter notebook viewing and execution directly in your EDS site. Code cells run in the browser with async/await support and ES6 imports. The block turns notebooks from static documentation into interactive development environments.</p>
        <p>Helper functions make testing straightforward. Import <code>testBlock()</code> to decorate components in isolation. Use <code>showPreview()</code> to display results in an overlay with responsive device testing. The preview system shows how your component renders on mobile, tablet, and desktop viewports without leaving the notebook.</p>
        <pre><code>import { testBlock, showPreview } from '/scripts/ipynb-helpers.js';

const block = await testBlock('accordion', '&#x3C;div>content&#x3C;/div>');

await showPreview(block.outerHTML, 'accordion');
</code></pre>
        <p>This approach creates living documentation. Your component examples become interactive tutorials that execute real code and display actual results. Content creators can see components working. Developers can test variations. Sales teams can demonstrate capabilities. Everyone works from the same executable documentation.</p>
        <p>The notebook format solves a problem in web development - documentation that goes stale. Traditional documentation describes how things worked when written. Notebooks execute current code, so they either work or fail visibly. No ambiguity, no wondering if the example still applies.</p>
        <h2 id="ai-integration">AI Integration</h2>
        <p>The framework integrates an AI assistant via Claude Code. Twenty-one skills from three sources provide capabilities. Adobe contributes six EDS-specific workflow skills from its Helix website repository. Anthropic provides eight general-purpose skills for document processing and development tools. Seven custom skills add EDS testing and documentation features.</p>
        <p>Skills alone aren't enough. A skill that tells an AI assistant "create a block following best practices" provides process guidance but lacks implementation knowledge. The skill knows what to do but not how to do it. That's where the documentation framework becomes essential.</p>
        <p>The documentation files contain the implementation knowledge that makes skills effective. When content-driven development orchestrates block creation, it relies on detailed documentation to understand the EDS architecture, design patterns, CSS approaches, and testing strategies. Skills provide workflow orchestration, and documentation provides implementation knowledge.</p>
        <p>Twelve slash commands give quick access to everyday tasks—type<code>/new-block</code> to start the Content Driven Development process. Use <code>/test-block</code> to run testing. Call <code>/jupyter-notebook</code> to launch interactive testing environments. These commands combine skills and documentation to accomplish specific development tasks.</p>
        <p>Ten autonomous agents handle complex multi-step operations. The code-architecture-reviewer analyses your codebase for consistency. The frontend-error-fixer debugs browser console errors and build failures. The documentation-architect creates structured documentation. These agents work independently on substantial tasks while you focus on other work.</p>
        <h2 id="browser-based-testing">Browser-Based Testing</h2>
        <p>Browser-based testing changes how you develop components. The jupyter-notebook-testing skill and ipynb-viewer block create an environment where you write tests as notebook cells, execute them in your browser, and see results immediately.</p>
        <p>The testing system supports dual environments. Tests run in Node.js using jsdom for unit testing, then execute in actual browsers through the ipynb-viewer for integration testing. This catches both logic errors and browser-specific issues without switching tools or contexts.</p>
        <p>The overlay preview system displays your components in different device contexts. Click a button to see how your component renders on mobile, tablet, or desktop. The preview overlays the current page so you can test in real browsers with real CSS, not simulations.</p>
        <pre><code>// Test in Node.js environment

const { JSDOM } = await import('jsdom');

const dom = new JSDOM('&#x3C;!DOCTYPE html>&#x3C;html>&#x3C;body>&#x3C;/body>&#x3C;/html>');

global.window = dom.window;

global.document = dom.window.document;

// Test the same code in the browser

const block = await testBlock('accordion', markup);

await showPreview(block.outerHTML, 'accordion');
</code></pre>
        <p>This dual-environment approach catches issues that single-environment testing misses. Your component works in Node.js but fails in Safari? The browser tests reveal that. Your CSS looks correct locally, but breaks in the deployed environment? The preview system shows the problem before deployment.</p>
        <p>The notebook format makes test results shareable. Send someone a link to your notebook, and they see what you see - the test code, the execution results, the visual output. No environment setup, no "works on my machine" problems. The notebook runs in their browser with your site's actual CSS and JavaScript.</p>
        <h2 id="development-without-build-steps">Development Without Build Steps</h2>
        <p>Simple components need no build process. Create a directory in <code>/blocks/</code>, add your JavaScript file, write your CSS, and start developing. The server serves files directly. Changes appear immediately. This direct-editing workflow applies to most EDS components.</p>
        <p>Complex components with external dependencies are placed in the <code>/build/</code> directory. Install npm packages, develop with modern tooling, then run the build script. The bundler creates self-contained files and copies them to <code>/blocks/</code>. Your deployed component has zero external dependencies despite using sophisticated libraries during development.</p>
        <pre><code>// Develop in /build/shoelace-card/ with dependencies

import { SlCard, SlButton } from '@shoelace-style/shoelace';

export default function decorate(block) {

  // Modern JavaScript with external dependencies

  // Bundled into self-contained blocks/ output

}
</code></pre>
        <p>This dual approach gives you flexibility. Use direct editing for straightforward components. Switch to the build workflow when you need external libraries or advanced features. Both patterns produce identical standard EDS blocks in production.</p>
        <h2 id="custom-utilities">Custom Utilities</h2>
        <p>The repository includes custom utility scripts that address specific development needs. The test-framework.js file provides a zero-dependency testing system with simple test registration and reporting. The ipynb-helpers.js file enables Jupyter Notebook testing by providing helper functions for block decoration and preview. The instrumentation.js file tracks performance metrics, function calls, and execution timing.</p>
        <p>These utilities solve problems encountered during actual development. They're practical solutions that emerged from building components and hitting obstacles. The build-component.js script automates the bundling workflow because manually copying files became tedious. The instrumented versions of EDS files exist because understanding performance requires detailed execution tracking.</p>
        <p>The framework also includes reference copies of Adobe's core EDS files - aem.js, scripts.js, and delayed.js. These aren't meant for production use. Get the latest versions from aem.live for actual projects. The reference copies demonstrate how these files work and serve as starting points for instrumented versions.</p>
        <h2 id="skills-plus-documentation">Skills Plus Documentation</h2>
        <p>Adobe's innovation with Claude Skills for EDS development provided workflow orchestration. Anthropic's Claude Code framework enabled context-aware skill activation. This repository adds the implementation knowledge layer that makes those orchestrations effective.</p>
        <p>Your EDS block fails, resulting in cryptic errors. You need help, but documentation is scattered across GitHub issues, Stack Overflow threads, and half-remembered conference talks. An AI assistant with skills but no implementation knowledge can tell you to "check the block decoration" or "validate your content model", but can't show you specifically what's wrong or how to fix it.</p>
        <p>The documentation framework provides that implementation knowledge. Detailed guides explain block architecture, decoration patterns, common mistakes, and solutions. Cross-references connect related concepts. Examples show working code. An AI assistant with both skills and documentation can analyse your specific situation, identify the actual problem, and suggest concrete fixes.</p>
        <p>This combination - workflow orchestration through skills, implementation knowledge through documentation, practical tools through utilities - creates an environment where AI assistants become helpful development partners rather than confused observers.</p>
        <h2 id="what-this-costs">What This Costs</h2>
        <p>The framework is free. MIT licensed, open source, available on GitHub. Clone it, modify it, use it in commercial projects: no fees, no subscriptions, no licensing restrictions.</p>
        <p>Runtime costs are zero. No external dependencies means no npm packages to install, no CDN fees, no third-party services. Your components bundle everything they need into self-contained JavaScript and CSS files. Deploy them anywhere that serves static files.</p>
        <p>Development costs reduce over time. The upfront investment is learning the patterns and understanding the documentation structure. After that, development accelerates. Components that take days with complex build systems take hours with direct editing. The AI integration further reduces time through automated workflows and instant access to implementation knowledge.</p>
        <p>Infrastructure costs are minimal. The development server runs on any machine with Node.js installed: no Docker containers, no Kubernetes clusters, no cloud services required for development. For production, you're running Adobe EDS - the framework adds nothing to your infrastructure needs.</p>
        <p>The hidden costs you avoid matter more. No npm audit warnings about vulnerable dependencies. No breaking changes when packages update. No time spent debugging build tool configurations. No security patches for external libraries. No license compatibility issues. The maintenance burden stays low because the code stays simple.</p>
        <h2 id="what-makes-this-approach-different">What Makes This Approach Different</h2>
        <p>Most frameworks assume complexity is necessary. They require build tools, transpilation, module bundlers, and layers of abstraction. This framework demonstrates the opposite. Start with simple tools and precise documentation. Add complexity only when needed.</p>
        <p>The zero-dependency philosophy isn't about avoiding useful libraries. It's about understanding what you actually need. Components can use external libraries during development, then bundle those dependencies into self-contained outputs. You get sophisticated UI elements without runtime dependencies or security vulnerabilities from outdated packages.</p>
        <p>The documentation-first approach recognises that code without context is just syntax. Every component includes detailed documentation that explains not just how it works but also why it works that way. The architectural decisions, the trade-offs, the alternatives considered - all captured in files that developers can understand.</p>
        <p>The ipynb-viewer block exemplifies this philosophy. Instead of building a complex testing framework with runners, reporters, and configuration files, the solution uses standard Jupyter notebooks executed in browsers. The format already exists, tools already support it, and people already understand it. The innovation is recognising that notebooks solve the testing documentation problem without creating new complexity.</p>
        <p>The AI integration acknowledges that development is changing. AI assistants aren't replacing developers; they're amplifying capabilities. But they need the correct information to be practical. Skills provide workflows, documentation includes knowledge, and utilities offer tools. Together, they create an environment where AI assistance helps rather than generating plausible-sounding but incorrect suggestions.</p>
        <h2 id="how-to-use-this-repository">How to Use This Repository</h2>
        <p>This repository is deliberately designed as a reference and learning project - not a production starter kit. The right approach for your next EDS project:</p>
        <p><strong>Cherry-pick what you need.</strong> Browse the documentation, examine the patterns, review the utilities. Take the ipynb-viewer block if you want interactive testing. Adopt the testing approach if dual-environment testing appeals to you. Copy the documentation structure if you need AI-friendly guides. Use the custom utilities if they solve your problems.</p>
        <p><strong>Start with Adobe's boilerplate.</strong> Always begin production projects with the latest official boilerplate from <a href="https://aem.live">aem.live</a>. Adobe maintains these files - aem.js, scripts.js, delayed.js - with the latest platform features and fixes. The versions in this repository are reference copies for learning and instrumentation, not production use.</p>
        <p><strong>Combine both approaches.</strong> Use Adobe's foundation, and add the innovations from this repository that suit your needs. The ipynb-viewer block works with any EDS project. The documentation patterns apply regardless of your starter template. The testing utilities integrate with standard EDS setups, and the AI skills and documentation support EDS development.</p>
        <p>The value here isn't in using this repository wholesale. It's in understanding the patterns, adopting the approaches that work for you, and building better EDS projects with proven techniques combined with Adobe's official foundation.</p>
        <h2 id="getting-started">Getting Started</h2>
        <p>For exploring this repository:</p>
        <pre><code>git clone https://github.com/ddttom/webcomponents-with-eds.git

cd webcomponents-with-eds

node server.js
</code></pre>
        <p>The server runs immediately with zero dependencies. This gets you started exploring the patterns and documentation.</p>
        <p>For full functionality - testing, linting, building complex components, and Jupyter notebook support - install the development dependencies:</p>
        <p><code>npm install</code></p>
        <p>This installs jsdom for Node.js testing, ESLint and markdownlint for code quality, and other development tools. None of these are runtime dependencies. Your deployed components remain zero-dependency.</p>
        <p>For Claude Code integration, install the hook dependencies:</p>
        <pre><code>cd .claude/hooks

npm install

cd ../..
</code></pre>
        <p>This enables the slash commands, skills, and agents. Skip this step if you're not using Claude Code - the framework works fine without it.</p>
        <p>For your actual project, start with Adobe's official boilerplate from <a href="https://aem.live">aem.live</a>, then cherry-pick the patterns and utilities from this repository that suit your needs.</p>
        <p>The repository includes standard EDS blocks for reference: accordion, cards, columns, and others. These demonstrate basic patterns and provide starting points. The value comes from the development environment and documentation system.</p>
        <p>Experiment with the ipynb-viewer block. Create a notebook with component tests. Execute cells to see results. Use the overlay preview to check responsive behaviour. The notebook becomes your development playground where ideas turn into working code quickly.</p>
        <p>Use the documentation system as a learning resource. Start with the audience-appropriate path - new developers, experienced developers, or architects. Follow the cross-references to explore related topics. The index file provides navigation between all documents.</p>
        <p>Experiment with AI integration if you use Claude Code. The slash commands provide access to common workflows. The skills activate automatically based on context. The agents handle complex tasks autonomously. See how AI assistance works when it has both orchestration and implementation knowledge.</p>
        <h2 id="whats-inside-the-repository">What's Inside the Repository</h2>
        <p>The repository represents substantial development effort across multiple languages and file types. The codebase contains hundreds of files organised into a working system.</p>
        <p><strong>Documentation</strong>: Markdown files form the knowledge base. This documentation serves both human developers and AI assistants, providing the implementation knowledge that makes the framework effective. The docs cover everything from basic EDS concepts to architecture patterns, testing strategies, and security guidelines.</p>
        <p><strong>Python Skills</strong>: Python files power document processing capabilities, including docx, pptx, xlsx, and PDF manipulation. These provide enterprise-grade document capabilities without external services. The skills integrate with Claude Code to enable sophisticated document workflows.</p>
        <p><strong>JavaScript</strong>: JavaScript files include the custom utilities, test frameworks, Jupyter helpers, instrumentation tools, and component implementations. These form the core development environment - the server, the testing system, the build tools, and the working components.</p>
        <p><strong>Supporting Files</strong>: CSS provides styling; JSON files configure tools and store data; Jupyter notebooks enable interactive testing; and HTML files provide documentation interfaces.</p>
        <p>The scale demonstrates commitment. This isn't a weekend project or a proof of concept. It's a working system, refined through actual use, thoroughly documented, and designed for long-term maintenance. You get access to all of it for free under an MIT licence.</p>
        <h2 id="the-practical-reality">The Practical Reality</h2>
        <p>This framework represents thousands of hours of development, testing, and refinement - the COCOMO model estimates it would cost over £3.5 million to build from scratch with a team of 16 developers working for two years. It's not a theoretical exercise - it's a working system used for actual EDS projects. The components are production-ready. The documentation reflects real challenges and solutions. The utilities solve problems encountered in practice.</p>
        <p>You don't need to adopt everything. Take the patterns that suit your needs. Use the documentation as a reference. Adapt the utilities for your context. The framework is deliberately designed as a "cherry-picker repository" - a collection of working examples and proven approaches you can incorporate into your own projects.</p>
        <p>The key insight remains simple. Sophisticated web development doesn't require complex toolchains. Clean thinking, good documentation, and proper AI integration achieve enterprise-level capabilities with zero external dependencies. This framework proves it.</p>
        <p>Find the repository here: <a href="https://github.com/ddttom/webcomponents-with-eds">https://github.com/ddttom/webcomponents-with-eds</a></p>
      </div>
      <div>
        <div class="fragment">
          <div>
            <div>/fragments/ddt/proposition</div>
          </div>
        </div>
        <div class="section-metadata">
          <div>
            <div>style</div>
            <div>bg-dark</div>
          </div>
        </div>
      </div>
      <div>
        <p>Related Articles</p>
        <div class="blogroll"></div>
        <div class="blogroll compact"></div>
        <div class="remove-icon-styles"></div>
        <div class="returntotop">
          <div>
            <div>Back to Top</div>
          </div>
        </div>
      </div>
    </main>
    <footer></footer>
  </body>
</html>
